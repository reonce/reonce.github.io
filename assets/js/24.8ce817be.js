(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{238:function(e,t,o){"use strict";o.r(t);var r=o(5),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h4",{attrs:{id:"proxy和object-defineproperty的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#proxy和object-defineproperty的区别"}},[e._v("#")]),e._v(" Proxy和Object.defineProperty的区别")]),e._v(" "),o("p",[o("strong",[e._v("Proxy的优势如下")])]),e._v(" "),o("ul",[o("li",[e._v("Proxy可以直接监听整个对象而非属性。")]),e._v(" "),o("li",[e._v("Proxy可以直接监听数组的变化。")]),e._v(" "),o("li",[e._v("Proxy有13中拦截方法，如"),o("code",[e._v("ownKeys、deleteProperty、has")]),e._v(" 等是 "),o("code",[e._v("Object.defineProperty")]),e._v(" 不具备的。")]),e._v(" "),o("li",[e._v("Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而"),o("code",[e._v("Object.defineProperty")]),e._v("只能遍历对象属性直接修改， 性能角度要好;")]),e._v(" "),o("li",[e._v("Proxy做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。")])]),e._v(" "),o("p",[o("strong",[e._v("Object.defineProperty 的优势如下")])]),e._v(" "),o("ul",[o("li",[e._v("兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。")])]),e._v(" "),o("p",[o("strong",[e._v("Object.defineProperty 不足在于")]),e._v("：")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("Object.defineProperty")]),e._v(" 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。")]),e._v(" "),o("li",[o("code",[e._v("Object.defineProperty")]),e._v("不能监听数组。是通过重写数据的那7个可以改变数据的方法来对数组进行监听的。")]),e._v(" "),o("li",[o("code",[e._v("Object.defineProperty")]),e._v(" 也不能对 "),o("code",[e._v("es6")]),e._v(" 新产生的 "),o("code",[e._v("Map")]),e._v(","),o("code",[e._v("Set")]),e._v(" 这些数据结构做出监听。")]),e._v(" "),o("li",[o("code",[e._v("Object.defineProperty")]),e._v("也不能监听新增和删除操作，通过 "),o("code",[e._v("Vue.set()")]),e._v("和 "),o("code",[e._v("Vue.delete")]),e._v("来实现响应式的。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);