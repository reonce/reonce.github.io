(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{264:function(e,t,o){"use strict";o.r(t);var s=o(5),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"浏览器中的event-loop"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的event-loop"}},[e._v("#")]),e._v(" 浏览器中的Event Loop")]),e._v(" "),o("p",[e._v("事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。\n常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。\n常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。")]),e._v(" "),o("blockquote",[o("p",[e._v("扩展一下process.nextTick()，它一般用于控制代码执行顺序，可用于赋予用户一种能力，去保证方法在对象完成constructor后但是在I/O发生前调用。它可扩展学习的内容也较多，后面单独介绍下。")])]),e._v(" "),o("p",[o("strong",[e._v("执行机制")]),e._v("：当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。")]),e._v(" "),o("h2",{attrs:{id:"node环境中的event-loop"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node环境中的event-loop"}},[e._v("#")]),e._v(" Node环境中的Event Loop")]),e._v(" "),o("p",[e._v("Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现")]),e._v(" "),o("p",[e._v("Node的Event loop一共分为6个阶段，每个细节具体如下：")]),e._v(" "),o("ul",[o("li",[e._v("timers: 执行setTimeout和setInterval中到期的callback。")]),e._v(" "),o("li",[e._v("pending callback: 上一轮循环中少数的callback会放在这一阶段执行。")]),e._v(" "),o("li",[e._v("idle, prepare:仅在内部使用。")]),e._v(" "),o("li",[e._v("poll:最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。")]),e._v(" "),o("li",[e._v("check:执行setImmediate的callback。")]),e._v(" "),o("li",[e._v("close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on('close, fn)。\n注意：上面六个阶段都不包括 process.nextTick()。\n在Node.js中，一次宏任务可以认为是包含上述6个阶段、"),o("strong",[e._v("微任务")]),e._v("microtask会在"),o("strong",[e._v("事件循环的各个阶段")]),e._v("之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。\nprocess.nextTick()")])]),e._v(" "),o("p",[e._v("在前面就已经了解到，process.nextTick()属于微任务，但是这里需要重点提及下：\nprocess.nextTick()虽然它是异步API的一部分，但未在图中显示。因为process.nextTick()从技术上讲，它不是事件循环的一部分；\n当每个阶段完成后，如果存在 nextTick，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行（可以理解为微任务中优先级最高的）")])])}),[],!1,null,null,null);t.default=n.exports}}]);