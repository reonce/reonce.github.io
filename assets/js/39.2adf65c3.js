(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{246:function(t,e,a){"use strict";a.r(e);var s=a(5),_=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_14-1-4-text类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-4-text类型"}},[t._v("#")]),t._v(" 14.1.4 Text类型")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("Text 节点是由 Text 类型表示，也就是标签之间的文本字符")]),t._v(" "),a("p",[t._v("暴露了几个方法：")]),t._v(" "),a("ul",[a("li",[t._v("appendData(text)")]),t._v(" "),a("li",[t._v("deleteData(offset, count) 在 offset 开始删除 count个字符")]),t._v(" "),a("li",[t._v("insertData(offset, text)  在 offset 位置插入文本")]),t._v(" "),a("li",[t._v("replaceData(offset, count, text) 在 用 text 替换从 offset 开始的 count 个字符")]),t._v(" "),a("li",[t._v("splitText(offset) 在 offset 位置将文本拆分成两个文本节点")]),t._v(" "),a("li",[t._v("subStringData(offset, count) 提取从位置 offset 到 offset+count  的文本")])]),t._v(" "),a("p",[t._v("只要开始标签和结束标签之间有内容（包括空格） 就会创建一个文本节点")]),t._v(" "),a("h2",{attrs:{id:"创建文本节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建文本节点"}},[t._v("#")]),t._v(" 创建文本节点")]),t._v(" "),a("p",[t._v("Document.createTextNode() 接收一个要插入节点的文本， ownerDocument 会被设置为 document")]),t._v(" "),a("p",[t._v("一个元素中可以包含多个文本节点")]),t._v(" "),a("h2",{attrs:{id:"规范化文本节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规范化文本节点"}},[t._v("#")]),t._v(" 规范化文本节点")]),t._v(" "),a("p",[t._v("在"),a("strong",[t._v("14.1 node节点")]),t._v(" 章节，有提到的方法  "),a("code",[t._v("normalize（）")]),t._v(" 可以将同一个标签内的文本节点合并并且去除空的文本节点")]),t._v(" "),a("h2",{attrs:{id:"拆分文本节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拆分文本节点"}},[t._v("#")]),t._v(" 拆分文本节点")]),t._v(" "),a("p",[t._v("和 "),a("code",[t._v("normalize()")]),t._v(" 方法相反的方法 "),a("code",[t._v("splitText()")]),t._v(" 接收一个参数，需要拆分的位置。可以把一个文本节点拆分成两个")])])}),[],!1,null,null,null);e.default=_.exports}}]);