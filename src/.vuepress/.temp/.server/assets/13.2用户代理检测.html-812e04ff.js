import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper-cc2b3d55.js";
const _sfc_main = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="_13-2用户代理检测" tabindex="-1"><a class="header-anchor" href="#_13-2用户代理检测" aria-hidden="true">#</a> 13.2用户代理检测</h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p>在http1.0和1.1的协议中，要求浏览器应该向服务器发送一段包含<strong>浏览器名称</strong>和<strong>版本信息</strong>的字符串 通过浏览器携带的<strong>用户代理字符串</strong>来判断当前是什么浏览器的方法叫做<strong>用户代理检测</strong></p><h2 id="早期的使用" tabindex="-1"><a class="header-anchor" href="#早期的使用" aria-hidden="true">#</a> 早期的使用</h2><p>美国国家超级计算机中心发布于1993年的<code>Mosaic</code>是早期web浏览器的代表。它的用户代理字符串格式是： <code>Mosaic/0.9</code> 后面崛起的网景公司开发浏览器时，将 浏览器代号取为 <code>Mozilla</code> （Mosaic Killer） 最开始它的字符串格式是这样的<code>Mozilla/Version [language] (Platform; Encryption)</code> 除了http要求的信息，它还额外携带了当前语言、操作系统和加密类型</p><p>1996年，网景的Netscape Navigator3发布后超越了<code>Mosaic成为了最受欢迎的浏览器，它有多受欢迎，从后来的许多新浏览器的浏览器名称都要取做 </code>Mozilla<code> 就可得知。 在Netscape Navigator3发布不久，微软就发布了IE浏览器，令人惊奇的是，它的浏览器名称竟然也取做了**Mozilla**，很显然，它违背了协议规定的初衷，它伪造成了Netscape Navigator3浏览器，以规避一些用户代理检测的判断（不是</code>Mosaic<code>的浏览器就做不兼容处理), 引发了一些争议。但当时主流的Mozilla已经是3.0版本了，前缀为 </code>Mozilla/3.0<code>，而Ie伪装的却是 </code>Mozilla/2.0\`</p><blockquote><p>这里我留一个猜想，可能是IE故意这样做的，以作为一个和网景浏览器的一个区别（为自己的一些未来考虑)，这样既规避了一些用户代理检测判断，又可以有自己的标识。</p></blockquote><p>用户代理字符串各个浏览器随着时间发展都多多少少改了很多版本，基本都把自己浏览器的标识放在了这个字符串的中间或结尾，为了兼容，它们 很有默契的仿照IE在前缀上使用了<strong>Mozilla</strong>。</p><h2 id="发展的规律" tabindex="-1"><a class="header-anchor" href="#发展的规律" aria-hidden="true">#</a> 发展的规律</h2><p>2003年苹果创建了 Safari浏览器的，它的渲染引擎叫做 Webkit， 基于Linux平台浏览器Konqueror使用的引擎KHTML开发的，苹果公司雇佣了一大批聪明、经验丰富的开发者，给他们时间和所需的资源去改进KHTML/KJS，在源码上修改，并且花了好几年的时间，诞生了 WebKit 。后来，谷歌浏览器又基于Webkit开发了Blink，由于两家公司的发展，谷歌公司有两个选择，要么获取Webkit的所有权，要么Copy平台的Webkit加以改进，然后取一个新名字，取得所有权。很显然，新的名字叫做Blink，当然谷歌也不是什么都没做的，它改进了非常多的东西，并且明确声称，将很快成为与原有 WebKit 有巨大差异的分支。 苹果公司也很聪明，反过来直接等谷歌更新了blink，直接合入Webkit，大家一起抄，反正都是开源。所以后面谷歌就不是很愿意贡献到开源代码了，在一些测试中，谷歌浏览器的页面崩溃率显然低于Safari，可能私有了一些未开源的改进吧。</p><blockquote><p>谷歌浏览器的渲染引擎是Blink，Js引擎是V8</p></blockquote><h2 id="现在的用户代理字符串" tabindex="-1"><a class="header-anchor" href="#现在的用户代理字符串" aria-hidden="true">#</a> 现在的用户代理字符串</h2><p>现在，所有基于Webkit内核的浏览器，都将自己标识为 Mozilla5.0。 苹果的回应和当初微软的回应一样： Safari与Mozilla兼容，不能让网站以为用户使用了不受支持的浏览器而把Safari排除在外。</p><h2 id="没伪造的特例" tabindex="-1"><a class="header-anchor" href="#没伪造的特例" aria-hidden="true">#</a> 没伪造的特例</h2><p>早期Opera浏览器是唯一一个使用产品名称和版本完全标识自身的主流浏览器，但后面很多改进也不得不有改成Mozilla的历史，后面甚至还根据访问网站不同设置不同的用户代理字符串，例如伪造成Firefox等。</p><h2 id="如何正确判断浏览器" tabindex="-1"><a class="header-anchor" href="#如何正确判断浏览器" aria-hidden="true">#</a> 如何正确判断浏览器</h2><p>如果相信浏览器返回的用户代理字符串，那就可以用<strong>用户代理检测</strong>。如果怀疑浏览器或脚本篡改这个值，那么最好还是用<strong>能力检测</strong></p><h2 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用" aria-hidden="true">#</a> 如何使用</h2><p>因为随着时间推移，新设备、浏览器、操作系统都会更新，用户代理字符串的更新是不可避免的，因此不推荐自己写方法判断。 建议使用一些开源的库，书中提到的，我写前三个： <code>Boweser</code> <code>UAParser.js</code> <code>Platform.js</code></p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../pages/posts/JavaScipt基础/红宝书/13.2用户代理检测.html.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _13_2_______html = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender], ["__file", "13.2用户代理检测.html.vue"]]);
export {
  _13_2_______html as default
};
