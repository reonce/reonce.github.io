# 查缺补漏
## 跨域

+ **Jsonp** 在<script>标签的src属性跟上请求的参数，只能get请求，不安全。

+ **window.name + iframe**   在页面的生命周期里共享一个window.name。 不安全,当前页面的可修改、最大为2M、只能传递字符串类型

  ```js
  <!-- 3b.html -->
  <script>
  window.name = '3a.html想要的3b.html里面的数据'; //这是就是我们需要通信的数据
  </script>
  　　
  <!-- 3a.html -->
  <html>
  <head>
  <script>
      function getData () {
          var iframe = document.getElementById('iframe');
          iframe.src = 'bbb.com/3b.html'; // 这里让iframe与父页面同源
           
          iframe.onload = function () {
              var data = iframe.contentWindow.name; //在这里我们得到了跨域页面中传来的数据
          };
      }
  </script>
  </head>
  <body><br><iframe id="iframe"  src = 'bbb.com/3b.html' onload()="getData ()">
  1
  </iframe>
  1
  <br></body> </html>
  ```

+ **document.domain + iframe** 仅限主域相同，子域不同的场景。

  原理： 两个页面通过js强制设置document.domain为基础主域，实现同域

  ~~~js
  1.）父窗口：(http://www.domain.com/a.html)
  
  <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
  <script>
      document.domain = 'domain.com';
      var user = 'admin';
  </script>
  2.）子窗口：(http://child.domain.com/b.html)
  
  <script>
      document.domain = 'domain.com';
      // 获取父窗口中变量
      alert('get js data from parent ---> ' + window.parent.user);
  </script>
  ~~~

+ **window.postMessage** html5新特性，可以使用它来向其他window对象发送消息，无论这个window对象同不同源。

  postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
  a.） 页面和其打开的新窗口的数据传递
  b.） 多窗口之间消息传递
  c.） 页面与嵌套的iframe消息传递
  d.） 上面三个场景的跨域数据传递

  用法：postMessage(data,origin)方法接受两个参数
  data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
  origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

  ~~~js
  1.）a.html：(http://www.domain1.com/a.html)
  
  <iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
  <script>       
      var iframe = document.getElementById('iframe');
      iframe.onload = function() {
          var data = {
              name: 'aym'
          };
          // 向domain2传送跨域数据
          iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
      };
  
      // 接受domain2返回数据
      window.addEventListener('message', function(e) {
          alert('data from domain2 ---> ' + e.data);
      }, false);
  </script>
  2.）b.html：(http://www.domain2.com/b.html)
  
  <script>
      // 接收domain1的数据
      window.addEventListener('message', function(e) {
          alert('data from domain1 ---> ' + e.data);
  
          var data = JSON.parse(e.data);
          if (data) {
              data.number = 16;
  
              // 处理后再发回domain1
              window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
          }
      }, false);
  </script>
  ~~~

+ 跨域资源共享（CORS）

  普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

  需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。

  目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

  axios设置：

  ```javascript
  axios.defaults.withCredentials = true
  ```

 		Nodejs后台示例：

```javascript
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

## css权重

权值等级划分， 一般来说是划分4个等级：

　　　　第一等级：代表 内联样式，如 style=""，权值为 1,0,0,0；

　　　　第二等级：代表 ID选择器，如 #id="", 权值为 0,1,0,0；

　　　　第三等级：代表 calss | 伪类 | 属性 选择器，如 .class | :hover,:link,:target | [type], 权值 0,0,1,0；

　　　　第四等级：代表 标签 | 伪元素 选择器，如 p | ::after, ::before, ::fist-inline, ::selection, 权值 0,0,0,1；

　　　　此外，通用选择器（*），子选择器（>）， 相邻同胞选择器（+）等选择器不在4等级之内，所以它们的权值都为 0,0,0,0；

注： !important 权重无穷大

## css +~

##### 1、群组选择器（','）

```
/* 表示既h1，又h2 */h1, h2 {  color: red;}
```

##### 2、后代选择器（空格）

```
/* 表示 h1 下面的所有 span 元素，不管是否以 h1 为直接父元素 */h1 span {}
```

##### 3、子元素选择器（'>'）

选择直接子元素

```
/* 表示 h1 下面的所有以 h1 为直接父元素的 span 元素，注意必须以 h1 为直接父元素 */h1 > span { }
```

示例：下面第一个h1的两个strong元素是红色，第二个h1的strong元素将不变色

```
<h1>This is <strong>very</strong> <strong>very</strong> important.</h1><h1>This is <em>really <strong>very</strong></em> important.</h1>
h1 > strong {color:red;}
```

##### 4、相邻兄弟选择器（'+'）

选择紧接在另一个元素后的元素，而且二者有相同的父元素。

```
 <ul>    <li>List item 1</li>    <li>List item 2</li>    <li>List item 3</li>  </ul>  <ol>    <li>List item 1</li>    <li>List item 2</li>    <li>List item 3</li>  </ol>
```

![img](https://img2018.cnblogs.com/blog/1424359/201909/1424359-20190902221705614-429719645.png)

#####  5、兄弟选择器（'~'）

选择在某元素之后的所有兄弟元素，不一定要紧跟在后面，但必须得是相同父元素，即必须是同一级元素。

```
/* A之后的所有B元素，不一定要紧跟在A后面、相同父元素 */A ~ B{    }
```

## 伪类和伪元素的区别

伪类与伪元素的特性及其区别：

1. 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；
2. 伪元素本质上是创建了一个有内容的虚拟容器；
3. CSS3中伪类和伪元素的语法不同；
4. 可以同时使用多个伪类，而只能同时使用一个伪元素；

## 长宽比`2:1` 

1. Padding-bottom(200%)
2. aspect-ratio

## 禁止复制粘贴

## 取消请求

+ AbortController

## cjs/esm

## Package.json 

+ main

+ exports

+ version

+ ^1.2.3  第一个主版本不变，后面俩保持最新

+ ~1.2.3  前两个版本不变，最后那个保持最新

+devDep

+peerDep

  +vue3

## webpack

+ 提升构建速度

  + cache

  + thread提高线程

  + swc-loader

+ 优化体积

  + Webpack-bundle-analyzer
  + terser  ->代码压缩，css，丑化
  + Gzip/brotli -> not webpack

## js 压缩代码

+ terser

+ 空格

+ 变量名缩短

+ 预计算

## tree shaking

+ 基于ESM的静态分析
+ commonjs -> esm

## http状态码

+ 304
+ 206
+ 204
+ 201
+ 401
+ 405
+ 429  -> Rate Limit

## Http2

+ header, http1头部没有进行压缩
+ 多路复用
+ Frame/Stream/Message
+ Server Push
  + 和 websorket的区别

## vue3

+ Proxy/define

## Es6 Proxy

+ 代理
+ 不可变数据 -> immer.js

